"""
This type stub file was generated by pyright.
"""

def list_modi_winusb_paths(): # -> list[Any]:
    ...

class ModiWinUsb:
    def __init__(self) -> None:
        ...
    
    def list_usb_devices(self): # -> list[Any]:
        ...
    
    def find_device(self, path):
        ...
    
    def init_winusb_device(self, path): # -> bool:
        ...
    
    def close_winusb_device(self): # -> bool:
        ...
    
    def get_last_error_code(self):
        ...
    
    def query_device_info(self, query=...): # -> Any | Literal[-1]:
        ...
    
    def query_interface_settings(self, index): # -> None:
        ...
    
    def change_interface(self, index, alternate=...): # -> bool:
        ...
    
    def query_pipe(self, pipe_index): # -> None:
        ...
    
    def control_transfer(self, setup_packet, buff=...): # -> dict[str, Any | list[Any | c_ubyte]]:
        ...
    
    def write(self, pipe_id, write_buffer): # -> int:
        ...
    
    def read(self, pipe_id, length_buffer): # -> list[Any] | Array[c_char] | None:
        ...
    
    def set_timeout(self, pipe_id, timeout):
        class POLICY_TYPE:
            ...
        
        
    
    def flush(self, pipe_id):
        ...
    
    def overlapped_read_init(self, pipe_id, length_buffer): # -> bool:
        ...
    
    def overlapped_read(self, pipe_id): # -> str | None:
        """ keep on reading overlapped, return bytearray, empty if nothing to read, None if err"""
        ...
    


class ModiWinUsbComPort:
    def __init__(self, path=..., baudrate=..., timeout=..., write_timeout=..., start=...) -> None:
        ...
    
    def open(self): # -> Literal[False] | None:
        ...
    
    @property
    def in_waiting(self): # -> Literal[False]:
        ...
    
    @property
    def timeout(self): # -> float:
        ...
    
    @timeout.setter
    def timeout(self, value): # -> None:
        ...
    
    @property
    def write_timeout(self): # -> int:
        ...
    
    @write_timeout.setter
    def write_timeout(self, value): # -> None:
        ...
    
    @property
    def baudrate(self): # -> int:
        ...
    
    @baudrate.setter
    def baudrate(self, value): # -> None:
        ...
    
    def readinto(self, buf): # -> int | None:
        ...
    
    def read(self, size=...): # -> bytes | None:
        ...
    
    def readline(self, size=...): # -> bytes | None:
        ...
    
    def read_all(self): # -> bytes | None:
        ...
    
    def write(self, data): # -> None:
        ...
    
    def setControlLineState(self, RTS=..., DTR=...): # -> None:
        ...
    
    def setLineCoding(self, baudrate=..., parity=..., databits=..., stopbits=...): # -> None:
        ...
    
    def disconnect(self): # -> None:
        ...
    
    def __del__(self): # -> None:
        ...
    
    def reset_input_buffer(self): # -> None:
        ...
    
    def reset_output_buffer(self): # -> None:
        ...
    
    def flush(self): # -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def flushInput(self): # -> None:
        ...
    
    def flushOutput(self): # -> None:
        ...
    
    def setDTR(self, state): # -> None:
        ...
    
    def setRTS(self, state): # -> None:
        ...
    


if __name__ == "__main__":
    paths = ...
